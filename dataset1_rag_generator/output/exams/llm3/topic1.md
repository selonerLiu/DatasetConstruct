# topicï¼šTheoretical foundation of ProVerif's formal description language (applied pi-calculus).

Here are 10 multiple-choice questions based on the provided content, designed to test students' understanding of the theoretical foundation of ProVerif's formal description language (applied pi-calculus):

---

**1. What is the input language of ProVerif based on?**  
A) The standard pi calculus without extensions.  
B) A dialect of the applied pi calculus introduced by Abadi and Fournet.  
C) A subset of first-order logic.  
D) The lambda calculus with cryptographic primitives.  
**Answer:** B  

---

**2. How does the applied pi calculus extend the standard pi calculus?**  
A) By adding probabilistic transitions.  
B) By introducing function symbols defined by an equational theory.  
C) By removing communication channels.  
D) By supporting only linear types.  
**Answer:** B  

---

**3. What is one key difference between ProVerif and the applied pi calculus?**  
A) ProVerif does not support any equational theories.  
B) ProVerif uses destructors instead of equational theories.  
C) The applied pi calculus has built-in error-handling constructs.  
D) ProVerif does not support cryptographic primitives.  
**Answer:** B  

---

**4. Which of the following does ProVerif support for modeling cryptographic primitives?**  
A) Only rewrite rules.  
B) Only equations.  
C) Both rewrite rules and equations.  
D) Neither rewrite rules nor equations.  
**Answer:** C  

---

**5. What security properties can ProVerif verify?**  
A) Only secrecy.  
B) Only authentication.  
C) Secrecy, authentication, and some observational equivalence properties.  
D) Only observational equivalence.  
**Answer:** C  

---

**6. What is the relationship between ProVerif's calculus and the applied pi calculus?**  
A) They are identical in all aspects.  
B) ProVerif's calculus is a strict subset of the applied pi calculus.  
C) They are extensions of the pi calculus but differ in handling equations and error-handling.  
D) ProVerif's calculus is unrelated to the applied pi calculus.  
**Answer:** C  

---

**7. How does ProVerif handle error conditions during expression evaluation?**  
A) It ignores errors silently.  
B) It uses a built-in else branch for error-handling.  
C) It aborts the entire verification process.  
D) It relies on external error-handling libraries.  
**Answer:** B  

---

**8. What does ProVerif prove that is stronger than observational equivalence in the applied pi calculus?**  
A) Trace equivalence.  
B) Di-equivalence.  
C) Weak bisimulation.  
D) Strong bisimulation.  
**Answer:** B  

---

**9. Which of the following is NOT a feature of ProVerif's input language?**  
A) Support for destructors.  
B) Built-in error-handling constructs.  
C) Full support for all equational theories.  
D) Extension of the pi calculus with cryptography.  
**Answer:** C  

---

**10. What is the primary purpose of ProVerif's automatic translator?**  
A) To convert the applied pi calculus into ProVerif's dialect.  
B) To translate protocol models and security properties into Horn clauses.  
C) To generate human-readable summaries of attacks.  
D) To optimize cryptographic primitives for performance.  
**Answer:** B  

--- 

Each question adheres to the demands, with clear descriptions, plausible distractors, and unambiguous answers. The format is consistent with the provided example.